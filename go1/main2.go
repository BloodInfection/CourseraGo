/* если большой массив данных+тесты*/
package main

import (
	"bufio" /*буферезированный ввод вывод*/
	"fmt"   /*форматированный вывод*/
	"io"    /*интерфейс ридер и врайтер(импорт ио) для потоков чтения и записи в ф-ии unique*/
	"os"    /*для стандартного ввода*/
)

func uniq(input io.Reader, output io.Writer) error /*вернет в случае ошибки*/ { /*принимает на вход поток из которого будем читать + поток, куда будем писать результат*/
	/*для того чтобы читать ввод не посимвольно а сразу всей строкой, нужен сканнер ввода из пакета бафио*/
	in := bufio.NewScanner(input) /*в сканер передается то что мы вводим, читаем из ридера(арг ф-ии)*/

	/*создадим переменную для предыдущего значения, будет выводить уникальные
	значения только в том случае, если файл отсортирован*/
	var prev string

	for in.Scan() { /*цикл считывает построчно и записывает в переменную то что мы считали(скан из пакета бафио)*/
		txt := in.Text()
		if txt == prev { /*если считываемая строка = предыдущему значению, выходим из цикла и не выводим ее*/
			continue
		}
		if txt < prev { /*если считываемая строка меньше предыдущего значения - файл не отсортирован, возвращаем ошибку*/
			return fmt.Errorf("file not sorted")
		}

		prev = txt /*меняем предыдущее значение на текущее для корректного сравнения*/

		fmt.Fprintln(output, txt) /*во всех остальных случаях выводим строку, фпринтлн для того чтобы писать в аутпут*/

	}
	/*в конце программы вернем нил, чтобы сказать, что никакой ошибки не было*/
	return nil
}

func main() {

	err := uniq(os.Stdin, os.Stdout)
	if err != nil {
		panic(err.Error())
	}
}

/*Команда cat — Являясь сокращением английского слова «concatenate»
(конкатенация), она позволяет создавать, объединять, а
также выводить содержимое файлов в командной строке или в другом файле.
cat data_sorted.txt | go run main2.go
*/
